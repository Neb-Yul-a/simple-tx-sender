<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simple Ethereum Tx Sender</title>
    <!-- Ethers.js v6 UMD CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.15.0/ethers.umd.min.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 2rem;
      }
      label {
        display: block;
        margin: 0.5rem 0;
      }
      input,
      textarea,
      select {
        width: 100%;
        padding: 0.5rem;
        margin-top: 0.2rem;
        font-family: monospace;
      }
      textarea {
        resize: vertical;
      }
      button {
        padding: 0.6rem 1.2rem;
        margin-top: 1rem;
        cursor: pointer;
      }
      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      #status,
      #txStatus {
        margin-top: 1rem;
        white-space: pre-wrap;
      }
      .row {
        display: flex;
        gap: 1rem;
        align-items: center;
        flex-wrap: wrap;
      }
      .row > * {
        flex: 1 1 auto;
      }
      .muted {
        color: #666;
        font-size: 0.9em;
      }
      #signedBox {
        margin-top: 1rem;
      }
    </style>
  </head>
  <body>
    <!-- Wallet selection if multiple providers detected -->
    <div id="providerSelectContainer" style="display: none">
      <label for="providerSelect"
        >Select Wallet:
        <select id="providerSelect"></select>
      </label>
    </div>

    <div class="row">
      <button id="connectButton">Connect Wallet</button>
      <div id="status">Not connected</div>
    </div>

    <label>
      To:
      <input type="text" id="toInput" placeholder="0x..." />
    </label>
    <label>
      Value (ETH):
      <input type="text" id="valueInput" placeholder="0.0" />
    </label>
    <label>
      Calldata (hex):
      <textarea
        id="dataInput"
        rows="10"
        placeholder="자동 설정 (빈칸 = ETH transfer)"
      ></textarea>
    </label>
    <label>
      Nonce (optional):
      <input type="text" id="nonceInput" placeholder="자동 설정" />
    </label>

    <div class="row">
      <button id="sendButton" disabled>Send Tx</button>
      <button id="signButton" disabled>Sign Tx (no send)</button>
    </div>

    <div class="row">
      <label style="flex: 1"
        >Max Priority Fee (gwei, optional)
        <input type="text" id="mpgInput" placeholder="0 = auto" />
      </label>
      <label style="flex: 1"
        >Max Fee (gwei, optional)
        <input type="text" id="mfgInput" placeholder="0 = auto" />
      </label>
    </div>

    <div id="txStatus"></div>

    <div id="signedBox" style="display: none">
      <label>
        Signed Raw Tx (hex):
        <textarea id="signedOutput" rows="4" readonly></textarea>
      </label>
      <div class="row">
        <button id="copySigned" style="flex: 0 0 auto">Copy</button>
        <div id="signedHash" class="muted"></div>
      </div>
      <div class="muted">
        Note: Some wallets (e.g. MetaMask extension) do not support
        <code>eth_signTransaction</code>. In that case, try Frame/OKX/Rabby or a
        wallet that supports sign-only.
      </div>
    </div>

    <script>
      // Populate wallet providers if multiple
      const providerSelectContainer = document.getElementById(
        "providerSelectContainer",
      );
      const providerSelect = document.getElementById("providerSelect");
      if (
        window.ethereum &&
        Array.isArray(window.ethereum.providers) &&
        window.ethereum.providers.length > 1
      ) {
        const list = window.ethereum.providers;
        list.forEach((p, idx) => {
          let name = "Provider " + idx;
          if (p.isMetaMask) name = "MetaMask";
          else if (p.isFrame) name = "Frame";
          else if (p.isOkxWallet || p.isOKXWallet) name = "OKX Wallet";
          const opt = document.createElement("option");
          opt.value = idx;
          opt.textContent = name;
          providerSelect.appendChild(opt);
        });
        providerSelectContainer.style.display = "block";
      }

      // Utility to get the selected provider
      function getProvider() {
        if (
          window.ethereum &&
          Array.isArray(window.ethereum.providers) &&
          window.ethereum.providers.length > 1
        ) {
          const idx = parseInt(providerSelect.value || "0", 10);
          return window.ethereum.providers[idx];
        }
        return window.ethereum || null;
      }

      const connectButton = document.getElementById("connectButton");
      const sendButton = document.getElementById("sendButton");
      const signButton = document.getElementById("signButton");
      const status = document.getElementById("status");
      const txStatus = document.getElementById("txStatus");
      const signedBox = document.getElementById("signedBox");
      const signedOutput = document.getElementById("signedOutput");
      const copySigned = document.getElementById("copySigned");
      const signedHash = document.getElementById("signedHash");

      const mpgInput = document.getElementById("mpgInput");
      const mfgInput = document.getElementById("mfgInput");

      let ethProvider = null;
      let rpcProvider = null; // ethers.BrowserProvider
      let signer = null;
      let userAddress = null;

      if (typeof ethers === "undefined") {
        alert("Ethers.js failed to load.");
        console.error("Ethers.js undefined");
      }

      // Connect / Disconnect
      connectButton.onclick = async () => {
        if (connectButton.textContent === "Connect Wallet") {
          ethProvider = getProvider();
          if (!ethProvider) return alert("No wallet found.");
          try {
            if (ethProvider.request)
              await ethProvider.request({ method: "eth_requestAccounts" });
            else if (ethProvider.enable) await ethProvider.enable();
            rpcProvider = new ethers.BrowserProvider(ethProvider);
            signer = await rpcProvider.getSigner();
            userAddress = await signer.getAddress();

            status.textContent = "Connected: " + userAddress;
            connectButton.textContent = "Connected";
            sendButton.disabled = false;
            signButton.disabled = false;
          } catch (err) {
            console.error(err);
            status.textContent = "Connection failed: " + (err.message || err);
          }
        } else {
          ethProvider = null;
          rpcProvider = null;
          signer = null;
          userAddress = null;
          status.textContent = "Not connected";
          connectButton.textContent = "Connect Wallet";
          sendButton.disabled = true;
          signButton.disabled = true;
          txStatus.textContent = "";
          signedBox.style.display = "none";
          signedOutput.value = "";
          signedHash.textContent = "";
        }
      };

      function aliasToAddress(input) {
        if (!input) return input;
        return input;
      }

      function toHex(bn) {
        return "0x" + bn.toString(16);
      }

      async function buildBaseTxParams() {
        if (!signer || !ethProvider || !rpcProvider || !userAddress)
          throw new Error("Connect first");
        let to = aliasToAddress(
          document.getElementById("toInput").value.trim(),
        );
        const data = document.getElementById("dataInput").value.trim();
        const valueEth = document.getElementById("valueInput").value.trim();
        const nonceVal = document.getElementById("nonceInput").value.trim();

        if (to && !ethers.isAddress(to)) throw new Error("Invalid To address");
        let valueBig;
        try {
          valueBig = ethers.parseEther(valueEth || "0");
        } catch {
          throw new Error("Invalid value");
        }

        const base = { from: userAddress, to, value: toHex(valueBig) };
        if (data) base.data = data;

        // Nonce
        if (nonceVal) {
          const n = parseInt(nonceVal, 10);
          if (isNaN(n) || n < 0) throw new Error("Invalid nonce");
          base.nonce = toHex(BigInt(n));
        } else {
          //const n = await rpcProvider.getTransactionCount(
          //  userAddress,
          //  "latest",
          //);
          //base.nonce = toHex(BigInt(n)); //set undefined
        }

        // Gas & Fees; remove gasEstimation. relying on wallets
        const eGasParams = { from: userAddress, data, value: valueBig };
        if (to) eGasParams.to = to;

        // User-specified EIP-1559 fees in gwei (0 or empty -> auto)
        const mpgStr = (mpgInput.value || "").trim();
        const mfgStr = (mfgInput.value || "").trim();
        const userMpg =
          mpgStr && mpgStr !== "0" ? ethers.parseUnits(mpgStr, "gwei") : null;
        const userMfg =
          mfgStr && mfgStr !== "0" ? ethers.parseUnits(mfgStr, "gwei") : null;

        let maxPriorityWei = userMpg;
        let maxFeeWei = userMfg;

        let computedBaseFee = null;
        let useEip1559 = false;

        if (maxPriorityWei && maxFeeWei && userMpg && userMfg) {
          useEip1559 = true;
        }

        if (!maxPriorityWei || !maxFeeWei) {
          try {
            const feeHistory = await rpcProvider.send("eth_feeHistory", [
              "0x2",
              "pending",
              [10, 20],
            ]);

            const baseFees = feeHistory?.baseFeePerGas;
            if (Array.isArray(baseFees) && baseFees.length) {
              const rawBase = baseFees[baseFees.length - 1];
              const baseWei = BigInt(rawBase);
              // Pad by 25% and round up to reduce the chance of underpricing
              computedBaseFee = (baseWei * 125n + 99n) / 100n;

              if (!maxPriorityWei) {
                const rewards = Array.isArray(feeHistory?.reward)
                  ? feeHistory.reward
                  : [];
                const lastRewardRow = rewards.length
                  ? rewards[rewards.length - 1]
                  : null;
                if (Array.isArray(lastRewardRow) && lastRewardRow.length > 1) {
                  const rewardHex = lastRewardRow[1];
                  try {
                    const rewardWei = BigInt(rewardHex);
                    if (rewardWei > 0n) maxPriorityWei = rewardWei;
                  } catch (_) {
                    /* ignore parse issues */
                  }
                }
              }

              if (!maxPriorityWei || maxPriorityWei === 0n) {
                maxPriorityWei = ethers.parseUnits("2", "gwei");
              }

              if (!maxFeeWei) {
                const baseComponent = computedBaseFee ?? baseWei;
                maxFeeWei = baseComponent + maxPriorityWei;
              }

              if (maxPriorityWei && maxFeeWei) useEip1559 = true;
            }
          } catch (err) {
            console.warn("eth_feeHistory failed", err);
          }
        }

        if (!maxPriorityWei || !maxFeeWei) {
          const fee = await rpcProvider.getFeeData();
          if (!maxPriorityWei && fee.maxPriorityFeePerGas)
            maxPriorityWei = fee.maxPriorityFeePerGas;
          if (!maxFeeWei && fee.maxFeePerGas) maxFeeWei = fee.maxFeePerGas;

          if (maxPriorityWei && maxFeeWei) {
            useEip1559 = true;
          } else if (fee.gasPrice) {
            base.gasPrice = toHex(fee.gasPrice);
          }
        }

        if (useEip1559 && maxPriorityWei && maxFeeWei) {
          base.type = "0x2";
          base.maxPriorityFeePerGas = toHex(maxPriorityWei);
          base.maxFeePerGas = toHex(maxFeeWei);
        }

        const net = await rpcProvider.getNetwork();
        base.chainId = toHex(net.chainId);

        // Optional: access list (best-effort)
        try {
          const { accessList } = await ethProvider.request({
            method: "eth_createAccessList",
            params: [
              {
                from: base.from,
                to: base.to,
                value: base.value,
                data: base.data,
              },
              "latest",
            ],
          });
          if (Array.isArray(accessList)) {
            const toAddr = base.to.toLowerCase();
            const idx = accessList.findIndex(
              (e) => (e.address || "").toLowerCase() === toAddr,
            );
            if (idx !== -1 && accessList[idx].storageKeys.length <= 24)
              accessList.splice(idx, 1);
            if (base.type === "0x2") base.accessList = accessList;
          }
        } catch (_) {
          /* ignore */
        }

        return base;
      }

      // Send transaction via eth_sendTransaction (unchanged)
      sendButton.onclick = async () => {
        if (!signer || !ethProvider || !userAddress)
          return alert("Please connect your wallet first.");
        try {
          const txParams = await buildBaseTxParams();
          console.log("Sending txParams:", txParams);
          sendButton.disabled = true;
          txStatus.textContent = "Awaiting approval...";
          const txHash = await ethProvider.request({
            method: "eth_sendTransaction",
            params: [txParams],
          });
          txStatus.innerHTML =
            'Tx hash: <a href="https://etherscan.io/tx/' +
            txHash +
            '" target="_blank">' +
            txHash +
            "</a>";
        } catch (err) {
          console.error(err);
          txStatus.textContent = "Error: " + (err.message || err);
        } finally {
          sendButton.disabled = false;
        }
      };

      // Sign transaction only (no send)
      signButton.onclick = async () => {
        if (!signer || !ethProvider || !userAddress)
          return alert("Please connect your wallet first.");
        signedBox.style.display = "none";
        signedOutput.value = "";
        signedHash.textContent = "";
        try {
          const txParams = await buildBaseTxParams();
          console.log("Signing txParams:", txParams);
          signButton.disabled = true;
          txStatus.textContent = "Requesting signature...";

          let rawResp;
          try {
            // Preferred: direct RPC (works on Frame/OKX/Rabby; MetaMask may not support)
            rawResp = await ethProvider.request({
              method: "eth_signTransaction",
              params: [txParams],
            });
          } catch (e1) {
            // Fallback to signer.signTransaction if available
            if (signer && typeof signer.signTransaction === "function") {
              const populated = await signer.populateTransaction({
                ...(txParams.to && { to: txParams.to }),
                data: txParams.data,
                value: txParams.value,
                ...(txParams.nonce && { nonce: txParams.nonce }),
                maxFeePerGas: txParams.maxFeePerGas,
                maxPriorityFeePerGas: txParams.maxPriorityFeePerGas,
                //gasPrice: txParams.gasPrice,
                type: txParams.type ? Number(txParams.type) : undefined,
                //chainId: txParams.chainId,
                accessList: txParams.accessList,
              });
              console.log(populated);
              console.log(populated.gasLimit);
              rawResp = await signer.signTransaction(populated);
            } else {
              throw new Error(
                e1 && e1.message
                  ? e1.message +
                    " — Your wallet may not support sign-only. Try Frame/OKX/Rabby or a wallet that supports eth_signTransaction."
                  : "Wallet does not support sign-only signing",
              );
            }
          }

          // Normalize response to hex string
          let rawHex = "";
          if (typeof rawResp === "string") rawHex = rawResp;
          else if (rawResp && typeof rawResp === "object")
            rawHex = rawResp.signedTx || rawResp.raw || rawResp.tx || "";
          if (
            !rawHex ||
            typeof rawHex !== "string" ||
            !rawHex.startsWith("0x")
          ) {
            // Still show diagnostic but do not crash
            throw new Error(
              "Wallet returned unexpected format for signed tx. Inspect console.",
            );
          }

          const hash = ethers.keccak256(rawHex);
          signedOutput.value = rawHex;
          signedHash.textContent =
            "Tx hash (keccak of signed raw): " + hash + " — not broadcasted";
          signedBox.style.display = "block";
          txStatus.textContent =
            "Signed only. Save the raw hex to broadcast later.";
        } catch (err) {
          console.error(err);
          txStatus.textContent = "Sign error: " + (err.message || err);
        } finally {
          signButton.disabled = false;
        }
      };

      copySigned.onclick = async () => {
        try {
          await navigator.clipboard.writeText(signedOutput.value.trim());
          signedHash.textContent += "  — Copied";
        } catch (_) {}
      };
    </script>
  </body>
</html>
